---
import AboutSection from "@components/AboutSection.astro";

// Fetch GitHub language statistics at build time
const GITHUB_TOKEN = import.meta.env.GITHUB_TOKEN;

interface LanguageStats {
  [language: string]: number;
}

async function fetchLanguageStats(): Promise<LanguageStats> {
  if (!GITHUB_TOKEN) {
    console.warn("GITHUB_TOKEN not set. Skipping language stats fetch.");
    return {};
  }

  try {
    const startTime = Date.now();

    // Fetch all repositories with pagination support
    let allRepos: any[] = [];
    let page = 1;
    let hasMorePages = true;

    while (hasMorePages) {
      const reposResponse = await fetch(
        `https://api.github.com/user/repos?per_page=100&page=${page}&affiliation=owner,collaborator,organization_member&sort=updated`,
        {
          headers: {
            Authorization: `Bearer ${GITHUB_TOKEN}`,
            Accept: "application/vnd.github.v3+json",
          },
        }
      );

      if (!reposResponse.ok) {
        if (reposResponse.status === 403) {
          const rateLimitRemaining = reposResponse.headers.get(
            "x-ratelimit-remaining"
          );
          const rateLimitReset = reposResponse.headers.get("x-ratelimit-reset");
          const resetDate = rateLimitReset
            ? new Date(parseInt(rateLimitReset) * 1000).toLocaleString()
            : "unknown";

          console.error(
            `GitHub API rate limit exceeded. Remaining: ${rateLimitRemaining}. Resets at: ${resetDate}`
          );
          throw new Error(
            `GitHub API rate limit exceeded. Resets at: ${resetDate}`
          );
        }
        throw new Error(`GitHub API error: ${reposResponse.status}`);
      }

      const repos = await reposResponse.json();
      allRepos = allRepos.concat(repos);

      // Check if there are more pages by examining the Link header
      const linkHeader = reposResponse.headers.get("Link");
      hasMorePages = linkHeader ? linkHeader.includes('rel="next"') : false;

      if (hasMorePages) {
        page++;
      }
    }

    const nonForkRepos = allRepos.filter((repo: any) => !repo.fork);

    console.log(
      `Fetched ${allRepos.length} repositories (${nonForkRepos.length} non-fork repositories)...`
    );

    console.log(
      `Fetching language data for ${nonForkRepos.length} repositories...`
    );

    // Fetch language data for all repositories in parallel (in batches to avoid rate limits)
    const BATCH_SIZE = 10;
    const languageStats: LanguageStats = {};

    for (let i = 0; i < nonForkRepos.length; i += BATCH_SIZE) {
      const batch = nonForkRepos.slice(i, i + BATCH_SIZE);

      const languagePromises = batch.map(async (repo: any) => {
        try {
          const langResponse = await fetch(repo.languages_url, {
            headers: {
              Authorization: `Bearer ${GITHUB_TOKEN}`,
              Accept: "application/vnd.github.v3+json",
            },
          });

          if (langResponse.ok) {
            return await langResponse.json();
          }

          if (langResponse.status === 403) {
            const rateLimitRemaining = langResponse.headers.get(
              "x-ratelimit-remaining"
            );
            const rateLimitReset =
              langResponse.headers.get("x-ratelimit-reset");
            const resetDate = rateLimitReset
              ? new Date(parseInt(rateLimitReset) * 1000).toLocaleString()
              : "unknown";

            console.warn(
              `GitHub API rate limit exceeded while fetching ${repo.name}. Remaining: ${rateLimitRemaining}. Resets at: ${resetDate}`
            );
          }

          return null;
        } catch (error) {
          console.warn(`Failed to fetch languages for ${repo.name}:`, error);
          return null;
        }
      });

      const results = await Promise.all(languagePromises);

      // Aggregate language bytes from this batch
      results.forEach((languages) => {
        if (languages) {
          for (const [lang, bytes] of Object.entries(languages)) {
            languageStats[lang] =
              (languageStats[lang] || 0) + (bytes as number);
          }
        }
      });
    }

    const duration = ((Date.now() - startTime) / 1000).toFixed(2);
    console.log(`Language stats fetched in ${duration}s`);

    return languageStats;
  } catch (error) {
    console.error("Error fetching GitHub language stats:", error);
    return {};
  }
}

const languageStats = await fetchLanguageStats();

// Languages to exclude
const EXCLUDED_LANGUAGES = [
  "Java",
  "C++",
  "C",
  "C#",
  "Ruby",
  "Dockerfile",
  "Shell",
  "Hack",
];

// Filter out excluded languages
const filteredStats = Object.entries(languageStats).filter(
  ([name]) => !EXCLUDED_LANGUAGES.includes(name)
);

// Calculate total bytes and sort by usage
const totalBytes = filteredStats.reduce((sum, [, bytes]) => sum + bytes, 0);
const sortedLanguages =
  totalBytes > 0
    ? filteredStats
        .map(([name, bytes]) => ({
          name,
          bytes,
          percentage: ((bytes / totalBytes) * 100).toFixed(1),
        }))
        .sort((a, b) => b.bytes - a.bytes)
        .slice(0, 8) // Show top 8 languages
    : [];
---

<AboutSection secondaryHeadline="Language Breakdown">
  <div
    class="grid gap-3 p-3 m-3 bg-mid-blue border border-black border-t-highlight border-l-highlight"
  >
    {
      sortedLanguages.length > 0 ? (
        <ol class="flex flex-col gap-3">
          {sortedLanguages.map((lang) => (
            <li class="px-3 bg-dark-blue border border-black  border-t-highlight border-l-highlight">
              <h3 class="text-light-blue font-mono">{lang.name}</h3>
            </li>
          ))}
        </ol>
      ) : (
        <p class="text-sm">Language statistics unavailable</p>
      )
    }
  </div>
</AboutSection>
